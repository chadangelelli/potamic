<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>potamic.queue documentation</title><link rel="stylesheet" type="text/css" href="css/highlight.css" /><link id="theme-style" rel="stylesheet" type="text/css" href="css/theme-light.css" /><link id="highlight-style" rel="stylesheet" type="text/css" href="css/highlight-googlecode.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1><div id="theme-selector"><span class="theme-label">Theme</span><div id="select-theme-light" class="select-theme">Light</div><div id="select-theme-dark" class="select-theme">Dark</div></div></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>potamic</span></div></div></li><li class="depth-2"><a href="potamic.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-3"><a href="potamic.db.validation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>validation</span></div></a></li><li class="depth-2 branch"><a href="potamic.errors.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>errors</span></div></a></li><li class="depth-2 branch"><a href="potamic.fmt.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fmt</span></div></a></li><li class="depth-2 current"><a href="potamic.queue.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>queue</span></div></a></li><li class="depth-3"><a href="potamic.queue.validation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>validation</span></div></a></li><li class="depth-2 branch"><a href="potamic.util.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2"><a href="potamic.validation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>validation</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="potamic.queue.html#var-create-queue"><div class="inner"><span>create-queue</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-destroy-queue.21"><div class="inner"><span>destroy-queue!</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-get-queue"><div class="inner"><span>get-queue</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-get-queues"><div class="inner"><span>get-queues</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-put"><div class="inner"><span>put</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-read"><div class="inner"><span>read</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-read-next.21"><div class="inner"><span>read-next!</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-read-pending"><div class="inner"><span>read-pending</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-read-pending-summary"><div class="inner"><span>read-pending-summary</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-read-range"><div class="inner"><span>read-range</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-set-processed.21"><div class="inner"><span>set-processed!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">potamic.queue</h1><h4 class="added">added in 0.1</h4><div class="doc"><div class="markdown"><p>Implements a stream-based message queue over Redis.</p>
</div></div><div class="public anchor" id="var-create-queue"><h3>create-queue</h3><div class="usage"><code>(create-queue queue-name conn &amp; opts)</code></div><div class="doc"><div class="markdown"><p>Creates a queue. Returns vector of <code>[ok? ?err]</code>.</p>
<p><strong>Options:</strong></p>
<table>
<thead>
<tr><th> Option     </th><th> Description       </th><th> Default            </th></tr>
</thead>
<tbody>
<tr><td> <code>:group</code>   </td><td> Sets reader group </td><td> <code>QUEUE-NAME-group</code> </td></tr>
<tr><td> <code>:init-id</code> </td><td> Initial ID        </td><td> <code>0</code>                </td></tr>
</tbody>
</table>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
'[potamic.queue :as q])

(def conn (first (db/make-conn :uri "redis://localhost:6379/0")))
;= {:spec {:uri "redis://localhost:6379/0"}
;=  :pool #taoensso.carmine.connections.ConnectionPool{..}}

(q/create-queue :my/queue conn)
;= [true nil]

(q/create-queue :secondary/queue conn :group :secondary/group)
;= [true nil]

(q/create-queue :third/queue conn :group :third/group :init-id 0)
;= [true nil]
</code></pre>
<p>See also:</p>
</div></div></div><div class="public anchor" id="var-destroy-queue.21"><h3>destroy-queue!</h3><div class="usage"><code>(destroy-queue! queue-name conn &amp; opts)</code></div><div class="doc"><div class="markdown"><p>Destroys a queue (stream) and the consumer group associated with it. Returns vector of <code>[ok? ?err]</code>.</p>
<p><em>WARNING</em>: Do not call this command unless you know it’s safe to do so!</p>
<p><strong>Options:</strong></p>
<table>
<thead>
<tr><th> Option     </th><th> Description                      </th><th> Default </th></tr>
</thead>
<tbody>
<tr><td> <code>:unsafe</code>  </td><td> Skip Pending Entries List checks </td><td> <code>false</code> </td></tr>
</tbody>
</table>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (first (db/make-conn :uri "redis://localhost:6379/0")))
;= {:spec {:uri "redis://localhost:6379/0"}
;=  :pool #taoensso.carmine.connections.ConnectionPool{..}}

(q/create-queue :my/queue conn)
;= [true nil]

(q/put :my/queue {:a 1} {:b 2} {:c 3})
;= [["1683933694431-0" "1683933694431-1" "1683933694431-2"] nil]

(q/read-next! 2 :from :my/queue :as :consumer/one)
;= [({:id "1683933694431-0", :msg {:a "1"}} {:id "1683933694431-1", :msg {:b "2"}}) nil]

;; only destroy if no pending messages (in this case will fail)
(q/destroy-queue! :my/queue conn)
;= [nil
;=  #:potamic{:err-type :potamic/db-err
;=            :err-msg "Cannot destroy my/queue, it has pending messages"
;=            :err-data
;=            {:args {:queue-name :my/queue :unsafe false}
;=             :groups [{:consumers 1
;=                       :entries-read 2
;=                       :last-delivered-id "1683933694431-1"
;=                       :name "my/queue-group"
;=                       :pending 2
;=                       :lag 1}]
;=             :consumers [{:idle 3371 :name "consumer/one" :pending 2}]}
;=            :err-file "[..]/potamic/src/potamic/queue.clj"
;=            :err-line 644
;=            :err-column 12}]

;; force-destroy, ignoring if there are pending messages
(q/destroy-queue! :my/queue conn :unsafe true)
;= [true nil]
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/create-queue</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-get-queue"><h3>get-queue</h3><div class="usage"><code>(get-queue queue-name)</code></div><div class="doc"><div class="markdown"><p>Returns queue spec for <code>queue-name</code>.</p>
</div></div></div><div class="public anchor" id="var-get-queues"><h3>get-queues</h3><div class="usage"><code>(get-queues)</code><code>(get-queues x)</code></div><div class="doc"><div class="markdown"><p>Get all, or a subset, of queues created via <code>potamic.queue/create-queue</code>. Return value varies depending on <code>x</code> input type.</p>
<table>
<thead>
<tr><th> Type      </th><th> Result                                         </th></tr>
</thead>
<tbody>
<tr><td> <code>nil</code>     </td><td> all queues                                     </td></tr>
<tr><td> <code>regex</code>   </td><td> map filtered by searching kv space for pattern </td></tr>
<tr><td> <code>vector</code>  </td><td> calls <code>get-in</code> for <code>x</code>                         </td></tr>
<tr><td> <code>keyword</code> </td><td> same as calling <code>(get-queue x)</code>                </td></tr>
</tbody>
</table>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn :uri "redis://localhost:6379/0"))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :queue/one)
;= [true nil]

(q/create-queue :queue/two)
;= [true nil]

(q/create-queue :another/three)
;= [true nil]

;;TODO: add search examples


</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/get-queue</code></li>
<li><code>potamic.queue/create-queue</code></li>
<li><code>potamic.queue/delete-queue</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-put"><h3>put</h3><div class="usage"><code>(put queue-name &amp; xs)</code></div><div class="doc"><div class="markdown"><p>Put message(s) onto a queue. Returns vector of <code>[?msg-ids ?err]</code>.</p>
<p><em>NOTE</em>: Because <code>put</code> can add more than one message, on success <code>?msg-ids</code> will always be a vector of ID strings, or <code>nil</code> on error.</p>
<p><em>NOTE</em>: It is highly recommended to let Redis set the ID automatically!</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn :uri "redis://localhost:6379/0"))
;= TODO: add output

(q/create-queue :my/queue conn)
;= TODO: add output

(q/put :my/queue {:a 1 :b 2 :c 3})
(q/put :my/queue :* {:a 1 :b 2 :c 3})
(q/put :my/queue "*" {:a 1 :b 2 :c 3})
(q/put :my/queue '* {:a 1 :b 2 :c 3})
;= [["1683660166747-0"] nil]

;; setting ID for a single message
(q/put :my/queue 1683743739-0 {:a 1})

;; setting the ID for a single message using wildcard.
(q/put :my/queue 1683743739-* {:a 1})

;; setting IDs for multi mode. the trailing `*` is required.
(q/put :my/queue 1683743739-* {:a 1} {:b 2} {:c 3})
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/read</code></li>
<li><code>potamic.queue/read-range</code></li>
<li><code>potamic.queue/read-next!</code></li>
<li><code>potamic.queue/read-pending-summary</code></li>
<li><code>potamic.queue/read-pending</code></li>
<li><code>potamic.queue/create-queue</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-read"><h3>read</h3><div class="usage"><code>(read queue-name &amp; {:keys [start block], cnt :count, :or {start 0}})</code></div><div class="doc"><div class="markdown"><p>Reads messages from a queue. Returns vector of <code>[?msgs ?err]</code>. This function wraps Redis’ <code>XREAD</code>. It does not involve groups, nor does it track pending entries. Also, it limits read to a single queue (stream).</p>
<p><code>?msgs</code> is of the form:</p>
<pre><code class="language-clojure">[{:id ID :msg MSG} ..]
</code></pre>
<p>All options have defaults:</p>
<table>
<thead>
<tr><th> Option   </th><th> Default Value                </th></tr>
</thead>
<tbody>
<tr><td> <code>:start</code> </td><td> <code>0</code> <em>(all messages)</em>         </td></tr>
<tr><td> <code>:count</code> </td><td> <code>nil</code> <em>(no limit)</em>           </td></tr>
<tr><td> <code>:block</code> </td><td> <code>nil</code> <em>(return immediately)</em> </td></tr>
</tbody>
</table>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q]
         '[clojure.core.async :as async])

(def conn (first (db/make-conn :uri "redis://localhost:6379/0")))
;= {:spec {:uri "redis://localhost:6379/0"}
;=  :pool #taoensso.carmine.connections.ConnectionPool{..}}

(q/create-queue :my/queue conn)
;= [true nil]

(q/put :my/queue {:a 1} {:b 2} {:c 3})
;= [["1683912716308-0" "1683912716308-1" "1683912716308-2"]
;=  nil]

(q/read :my/queue)
;= [({:id "1683913507471-0", :msg {:a "1"}}
;=   {:id "1683913507471-1", :msg {:b "2"}}
;=   {:id "1683913507471-2", :msg {:c "3"}})
;=  nil]

(q/read :my/queue :start 0)
;= [({:id "1683913507471-0", :msg {:a "1"}}
;=   {:id "1683913507471-1", :msg {:b "2"}}
;=   {:id "1683913507471-2", :msg {:c "3"}})
;=  nil]

(async/go (async/&lt;! (async/timeout 2000)) (q/put :my/queue {:d 4}))
;= #object[clojure.core.async.impl.channels.ManyToManyChannel ..]

;; block until above Go call executes
(q/read :my/queue :count 10 :start 0 :block [5 :seconds])
;= [({:id "1683915375766-0", :msg {:a "1"}}
;=   {:id "1683915375766-1", :msg {:b "2"}}
;=   {:id "1683915375766-2", :msg {:c "3"}}
;=   {:id "1683915435992-0", :msg {:d "4"}})
;=  nil]
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/read-next!</code></li>
<li><code>potamic.queue/put</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-read-next.21"><h3>read-next!</h3><div class="usage"><code>(read-next! consume &amp; {:keys [from as block]})</code></div><div class="doc"><div class="markdown"><p>Reads next message(s) from a queue as consumer for queue group, side-effecting Redis’ Pending Entries List. Returns vector of <code>[?msgs ?err]</code>.</p>
<p><code>?msgs</code> is of the form:</p>
<pre><code class="language-clojure">[{:id ID :msg MSG} ..]
</code></pre>
<p><em>NOTE</em>: <code>Readers</code> are responsible for declaring messages “processed” by calling <code>potamic.queue/set-processed!</code>.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn :uri "redis://localhost:6379/0"))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/put :my/queue {:a 1} {:b 2} {:c 3})
;= [["1683661383518-0" "1683661383518-1" "1683661383518-2"] nil]

(read-next! 1 :from :my/queue :as :my/consumer1)

(read-next! :all :from :my/queue :as :my/consumer1 :block 2000)
(read-next! :all :from :my/queue :as :my/consumer1 :block [2 :seconds])
;=
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/read</code></li>
<li><code>potamic.queue/read-pending</code></li>
<li><code>potamic.queue/read-pending-summary</code></li>
<li><code>potamic.queue/put</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-read-pending"><h3>read-pending</h3><div class="usage"><code>(read-pending queue-name &amp; {:keys [start end], cnt :count, :or {start "-", end "+"}})</code></div><div class="doc"><div class="markdown"><p>Lists details of pending messages for a <code>queue</code>. Returns vector of <code>[?details ?err]</code>.</p>
<p><code>?details</code> is of the form:</p>
<pre><code class="language-clojure"></code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/read-pending-summary</code></li>
<li><code>potamic.queue/set-processed!</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-read-pending-summary"><h3>read-pending-summary</h3><div class="usage"><code>(read-pending-summary queue-name)</code></div><div class="doc"><div class="markdown"><p>Lists all pending messages, for all consumers, for <code>queue</code>. Returns vector of <code>[?summary ?err]</code>.</p>
<p><code>?summary</code> is of the form:</p>
<pre><code class="language-clojure">{:total N
 :start ID
 :end ID
 :consumers {CONSUMER-NAME N-PENDING}}
</code></pre>
<p><em>NOTE</em>: <code>CONSUMER-NAME</code> is coerced by the rules of <code>util/&lt;-str</code>. The string <code>"my/consumer1"</code> becomes the keyword <code>:my/consumer</code>.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn :uri "redis://localhost:6379/0"))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :my/queue conn)
;= [true nil]

(q/put :my/queue {:a 1} {:b 2} {:c 3})
;= [["1683745855445-0" "1683745855445-1" "1683745855445-2"]
;=  nil]

(q/read-next! 2 :from :my/queue :as :consumer/one)
;= [({:id "1683745855445-0" :msg {:a "1"}}
;=   {:id "1683745855445-1" :msg {:b "2"}})
;=  nil]

(q/read-next! 1 :from :my/queue :as :consumer/two)
;= [({:id "1683745855445-2" :msg {:c "3"}})
;=  nil]

(q/read-pending-summary :my/queue)
;= [{:total 3
;=   :start "1683745855445-0"
;=   :end "1683745855445-2"
;=   :consumers #:consumer{:one 2 :two 1}}
;=  nil]
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/read-pending</code></li>
<li><code>potamic.queue/set-processed!</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-read-range"><h3>read-range</h3><div class="usage"><code>(read-range queue-name &amp; {:keys [start end], cnt :count, :or {start "-", end "+"}})</code></div><div class="doc"><div class="markdown"><p>Reads a range of messages from a queue. Returns vector of <code>[?msgs ?err]</code>. This function wraps Redis’ <code>XRANGE</code>. It does not involve groups, nor does it track pending entries.</p>
<p><code>?msgs</code> is of the form:</p>
<pre><code class="language-clojure">[{:id ID :msg MSG} ..]
</code></pre>
<p>All options have defaults:</p>
<table>
<thead>
<tr><th> Option   </th><th> Default Value      </th></tr>
</thead>
<tbody>
<tr><td> <code>:start</code> </td><td> <code>-</code> <em>(oldest)</em>     </td></tr>
<tr><td> <code>:end</code>   </td><td> <code>+</code> <em>(newest)</em>     </td></tr>
<tr><td> <code>:count</code> </td><td> <code>nil</code> <em>(no limit)</em> </td></tr>
</tbody>
</table>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn :uri "redis://localhost:6379/0"))

;; read all using defaults (same as `(q/read :my/queue)`).
(q/read-range :my/queue)
;= TODO: add output

;; start at a specific time
(q/read-range :my/queue :start 1683661383518-0)
;= TODO: add output

;; start at a specific time, returning at most 10
(q/read-range :my/queue :start 1683661383518-0 :end :+ :count 10)
;= TODO: add output
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/read-next!</code></li>
<li><code>potamic.queue/put</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-set-processed.21"><h3>set-processed!</h3><div class="usage"><code>(set-processed! queue-name &amp; msg-ids)</code></div><div class="doc"><div class="markdown"><p>Removes message(s) from Redis’ Pending Entries List. This command wraps Redis’ <code>XACK</code> command. Returns vector of <code>[?n-acked ?err]</code>.</p>
<p><em>NOTE</em>: (as per official Redis docs)</p>
<blockquote>
<p>“Certain message IDs may no longer be part of the PEL (for example because they have already been acknowledged), and XACK will not count them as successfully acknowledged.”</p>
</blockquote>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn :uri "redis://localhost:6379/0"))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :my/queue conn)
;= [true nil]

(q/put :my/queue {:a 1} {:b 2} {:c 3})
;= [["1683745855445-0" "1683745855445-1" "1683745855445-2"]
;=  nil]

(q/read-next! 1 :from :my/queue :as :consumer/one)
;= [({:id "1683745855445-0" :msg {:a "1"}})
;=  nil]

(q/set-processed! :my/queue "1683745855445-0")

(q/set-processed! :my/queue '1683745855445-1  '1683745855445-2)

</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/read-next!</code></li>
<li><code>potamic.queue/read-pending-summary</code></li>
<li><code>potamic.queue/read-pending</code></li>
</ul>
</div></div></div></div></body></html>