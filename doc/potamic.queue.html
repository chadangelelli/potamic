<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>potamic.queue documentation</title><link rel="stylesheet" type="text/css" href="css/highlight.css" /><link id="theme-style" rel="stylesheet" type="text/css" href="css/theme-light.css" /><link id="highlight-style" rel="stylesheet" type="text/css" href="css/highlight-googlecode.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1><div id="theme-selector"><span class="theme-label">Theme</span><div id="select-theme-light" class="select-theme">Light</div><div id="select-theme-dark" class="select-theme">Dark</div></div></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>potamic</span></div></div></li><li class="depth-2 branch"><a href="potamic.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-2 branch"><a href="potamic.fmt.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fmt</span></div></a></li><li class="depth-2 current"><a href="potamic.queue.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>queue</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="potamic.queue.html#var--.3Estr"><div class="inner"><span>-&gt;str</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-create-queue"><div class="inner"><span>create-queue</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-create-reader"><div class="inner"><span>create-reader</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-delete-queue"><div class="inner"><span>delete-queue</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-get-queue"><div class="inner"><span>get-queue</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-get-queues"><div class="inner"><span>get-queues</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-get-reader"><div class="inner"><span>get-reader</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-put"><div class="inner"><span>put</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-read"><div class="inner"><span>read</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-Valid-Create-Queue-Opts"><div class="inner"><span>Valid-Create-Queue-Opts</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">potamic.queue</h1><div class="doc"><div class="markdown"><p>Implements a stream-based message queue over Redis.</p>
</div></div><div class="public anchor" id="var--.3Estr"><h3>-&gt;str</h3><div class="usage"><code>(-&gt;str x)</code></div><div class="doc"><div class="markdown"><p>Returns a string representation of symbol. This is similar to calling <code>str</code> on a symbol except that keywords will not contain a preceding colon character. The keyword <code>:x/y</code> will yield “x/y” instead of “:x/y”.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.queue :as q])

(q/-&gt;str :my/queue "my/queue")
;= "my/queue"

(q/-&gt;str 'my/queue "my/queue")
;= "my/queue"

(q/-&gt;str "my/queue" "my/queue")
;= "my/queue"
</code></pre>
<p>See also:</p>
</div></div></div><div class="public anchor" id="var-create-queue"><h3>create-queue</h3><div class="usage"><code>(create-queue queue-name conn)</code><code>(create-queue queue-name conn {:keys [group id]})</code></div><div class="doc"><div class="markdown"><p>Creates a queue. If no options are provided, <code>:group</code> defaults to <code>QUEUE-NAME-group</code>. Returns vector of <code>[ok? ?err]</code>.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn {:uri "redis://localhost:6379/0"}))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :my/queue conn)
;= TODO: add output

(q/create-queue :my/queue conn {:group :my-named/queue-group})
;= TODO: add output
</code></pre>
<p>See also:</p>
</div></div></div><div class="public anchor" id="var-create-reader"><h3>create-reader</h3><div class="usage"><code>(create-reader {:keys [queue-name consume every]})</code></div><div class="doc"><div class="markdown"><p>Creates a <code>Reader</code> that reads <code>consume</code> at <code>every</code> (milliseconds). Returns running <code>Reader</code> instance (see <code>potamic.queue/get-reader</code>).</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn {:uri "redis://localhost:6379/0"}))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :my/queue conn)
;= TODO: add output

(def reader (q/create-reader {:queue :my/queue
                              :conn conn
                              :consume 1
                              :every 2000}))
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/get-reader</code></li>
<li><code>potamic.queue/create-queue</code></li>
<li><code>potamic.queue/put</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-delete-queue"><h3>delete-queue</h3><div class="usage"><code>(delete-queue)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-get-queue"><h3>get-queue</h3><div class="usage"><code>(get-queue queue-name)</code></div><div class="doc"><div class="markdown"><p>Returns queue spec for <code>queue-name</code>.</p>
</div></div></div><div class="public anchor" id="var-get-queues"><h3>get-queues</h3><div class="usage"><code>(get-queues)</code><code>(get-queues x)</code></div><div class="doc"><div class="markdown"><p>Get all, or a subset, of queues created via <code>potamic.queue/create-queue</code>. Return value varies depending on <code>x</code> input type.</p>
<table>
<thead>
<tr><th> Type      </th><th> Result                                      </th></tr>
</thead>
<tbody>
<tr><td> <code>nil</code>     </td><td> all queues                                  </td></tr>
<tr><td> <code>regex</code>   </td><td> map filtered by search kv space for pattern </td></tr>
<tr><td> <code>vector</code>  </td><td> calls <code>get-in</code> for <code>x</code>                      </td></tr>
<tr><td> <code>keyword</code> </td><td> same as calling <code>(get-queue x)</code>             </td></tr>
</tbody>
</table>
<p>See also:</p>
<ul>
<li><code>potamic.queue/get-queue</code></li>
<li><code>potamic.queue/create-queue</code></li>
<li><code>potamic.queue/delete-queue</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-get-reader"><h3>get-reader</h3><div class="usage"><code>(get-reader)</code></div><div class="doc"><div class="markdown"><p>Returns running <code>Reader</code> instance.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn {:uri "redis://localhost:6379/0"}))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :my/queue conn)
;= TODO: add output

(def rdr (q/create-reader conn :my/queue {:consume 1 :every 2000}))

(get-reader rdr)
;= TODO: add output
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/create-reader</code></li>
<li><code>potamic.queue/create-queue</code></li>
<li><code>potamic.queue/put</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-put"><h3>put</h3><div class="usage"><code>(put queue-name kvs)</code><code>(put queue-name id kvs)</code></div><div class="doc"><div class="markdown"><p>Put a message onto a queue. Returns vector of <code>[?res ?err]</code>.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">;; the following lines are identical
(put :my/queue {:a 1 :b 2 :c 3})
(put :my/queue :* {:a 1 :b 2 :c 3})
(put :my/queue "*" {:a 1 :b 2 :c 3})
(put :my/queue '* {:a 1 :b 2 :c 3})

;;TODO: update this fake example
(put :my/queue 123456789-0 {:a 1 :b 2 :c 3})
</code></pre>
<p>See also:</p>
</div></div></div><div class="public anchor" id="var-read"><h3>read</h3><div class="usage"><code>(read consume &amp; {:keys [from as]})</code></div><div class="doc"><div class="markdown"><p>Reads message(s) from <code>queue-name</code>. Returns vector of <code>[?msgs ?err]</code>.</p>
<p><em>NOTE</em>: <code>Readers</code> are responsible for declaring a message “processed”. That is, to call <code>(potamic.queue/set-message-state :processed)</code>.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(read 1 :from :my/queue :as :my/consumer1)
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/create-reader</code></li>
<li><code>potamic.queue/put</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-Valid-Create-Queue-Opts"><h3>Valid-Create-Queue-Opts</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div></div></body></html>