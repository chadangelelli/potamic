<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>potamic.queue documentation</title><link rel="stylesheet" type="text/css" href="css/highlight.css" /><link id="theme-style" rel="stylesheet" type="text/css" href="css/theme-light.css" /><link id="highlight-style" rel="stylesheet" type="text/css" href="css/highlight-googlecode.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1><div id="theme-selector"><span class="theme-label">Theme</span><div id="select-theme-light" class="select-theme">Light</div><div id="select-theme-dark" class="select-theme">Dark</div></div></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>potamic</span></div></div></li><li class="depth-2 branch"><a href="potamic.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-2 branch"><a href="potamic.fmt.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fmt</span></div></a></li><li class="depth-2 branch current"><a href="potamic.queue.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>queue</span></div></a></li><li class="depth-2"><a href="potamic.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="potamic.queue.html#var-create-queue"><div class="inner"><span>create-queue</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-create-reader"><div class="inner"><span>create-reader</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-delete-queue"><div class="inner"><span>delete-queue</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-get-queue"><div class="inner"><span>get-queue</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-get-queues"><div class="inner"><span>get-queues</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-get-reader"><div class="inner"><span>get-reader</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-put"><div class="inner"><span>put</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-read-next"><div class="inner"><span>read-next</span></div></a></li><li class="depth-1"><a href="potamic.queue.html#var-Valid-Create-Queue-Opts"><div class="inner"><span>Valid-Create-Queue-Opts</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">potamic.queue</h1><div class="doc"><div class="markdown"><p>Implements a stream-based message queue over Redis.</p>
</div></div><div class="public anchor" id="var-create-queue"><h3>create-queue</h3><div class="usage"><code>(create-queue queue-name conn)</code><code>(create-queue queue-name conn {:keys [group id]})</code></div><div class="doc"><div class="markdown"><p>Creates a queue. If no options are provided, <code>:group</code> defaults to <code>QUEUE-NAME-group</code>. Returns vector of <code>[ok? ?err]</code>.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn {:uri "redis://localhost:6379/0"}))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :my/queue conn)
;= [true nil]

(q/create-queue :my/queue conn {:group :my-named/queue-group})
;= [true nil]
</code></pre>
<p>See also:</p>
</div></div></div><div class="public anchor" id="var-create-reader"><h3>create-reader</h3><div class="usage"><code>(create-reader {:keys [queue-name consume every]})</code></div><div class="doc"><div class="markdown"><p>Creates a <code>Reader</code> that reads n-number of messages at an interval. Returns vector of <code>[?rdr ?err]</code> where <code>?rdr</code> is a running <code>Reader</code> instance (see <code>potamic.queue/get-reader</code>).</p>
<p><em>NOTE</em>: <code>Readers</code> are responsible for declaring messages “processed”. That is, to call <code>(potamic.queue/set-message-state :processed)</code>.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn {:uri "redis://localhost:6379/0"}))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :my/queue conn)
;= [true nil]

(def reader (q/create-reader conn :my/queue {:consume 1 :every 2000}))
;= TODO: add output

(def reader (q/create-reader conn
                             :my/queue
                             {:consume 1 :every [2 :seconds]}))
;= TODO: add output
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/read</code></li>
<li><code>potamic.queue/get-reader</code></li>
<li><code>potamic.queue/put</code></li>
<li><code>potamic.queue/create-queue</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-delete-queue"><h3>delete-queue</h3><div class="usage"><code>(delete-queue)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-get-queue"><h3>get-queue</h3><div class="usage"><code>(get-queue queue-name)</code></div><div class="doc"><div class="markdown"><p>Returns queue spec for <code>queue-name</code>.</p>
</div></div></div><div class="public anchor" id="var-get-queues"><h3>get-queues</h3><div class="usage"><code>(get-queues)</code><code>(get-queues x)</code></div><div class="doc"><div class="markdown"><p>Get all, or a subset, of queues created via <code>potamic.queue/create-queue</code>. Return value varies depending on <code>x</code> input type.</p>
<table>
<thead>
<tr><th> Type      </th><th> Result                                         </th></tr>
</thead>
<tbody>
<tr><td> <code>nil</code>     </td><td> all queues                                     </td></tr>
<tr><td> <code>regex</code>   </td><td> map filtered by searching kv space for pattern </td></tr>
<tr><td> <code>vector</code>  </td><td> calls <code>get-in</code> for <code>x</code>                         </td></tr>
<tr><td> <code>keyword</code> </td><td> same as calling <code>(get-queue x)</code>                </td></tr>
</tbody>
</table>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn {:uri "redis://localhost:6379/0"}))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :queue/one)
;= [true nil]

(q/create-queue :queue/two)
;= [true nil]

(q/create-queue :another/three)
;= [true nil]

;;TODO: add search examples


</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/get-queue</code></li>
<li><code>potamic.queue/create-queue</code></li>
<li><code>potamic.queue/delete-queue</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-get-reader"><h3>get-reader</h3><div class="usage"><code>(get-reader)</code></div><div class="doc"><div class="markdown"><p>Returns running <code>Reader</code> instance.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn {:uri "redis://localhost:6379/0"}))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/create-queue :my/queue conn)
;= [true nil]

(def rdr (q/create-reader {:queue :my/queue
                           :consume 1
                           :every 2000
                           :as :my/consumer1}))

(def rdr (q/create-reader {:queue :my/queue
                           :consume 1
                           :every [2 :seconds]
                           :as :my/consumer1}))

(get-reader rdr)
;= TODO: add output
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/create-reader</code></li>
<li><code>potamic.queue/create-queue</code></li>
<li><code>potamic.queue/put</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-put"><h3>put</h3><div class="usage"><code>(put queue-name id-or-msg1 &amp; msgs)</code></div><div class="doc"><div class="markdown"><p>Put a message onto a queue. Returns vector of <code>[?msg-ids ?err]</code>.</p>
<p><em>NOTE</em>: Because <code>put</code> can add more than one message, on success <code>?msg-ids</code> will always be a vector of ID strings (or <code>nil</code> on fail).</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">;; the following lines are identical
(put :my/queue {:a 1 :b 2 :c 3})
(put :my/queue :* {:a 1 :b 2 :c 3})
(put :my/queue "*" {:a 1 :b 2 :c 3})
(put :my/queue '* {:a 1 :b 2 :c 3})
;= [["1683660166747-0"] nil]

;;TODO: add example for multi-put

;;TODO: add example of manually setting ID
</code></pre>
<p>See also: - <code>potamic.queue/read</code> - <code>potamic.queue/create-queue</code> - <code>potamic.queue/create-reader</code></p>
</div></div></div><div class="public anchor" id="var-read-next"><h3>read-next</h3><div class="usage"><code>(read-next consume &amp; {:keys [from as block]})</code></div><div class="doc"><div class="markdown"><p>Reads next message(s) from a queue as consumer for queue group. Returns vector of <code>[?msgs ?err]</code>.</p>
<p><code>?msgs</code> is of the form:</p>
<pre><code class="language-clojure">[{:id ID :msg MSG} {:id ID :msg MSG} ..]
</code></pre>
<p><em>NOTE</em>: <code>Readers</code> are responsible for declaring messages “processed”. That is, to call <code>(potamic.queue/set-message-state :processed)</code>.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-clojure">(require '[potamic.db :as db]
         '[potamic.queue :as q])

(def conn (db/make-conn {:uri "redis://localhost:6379/0"}))
;= {:uri "redis://localhost:6379/0", :pool {}}

(q/put :my/queue {:a 1} {:b 2} {:c 3})
;= [["1683661383518-0" "1683661383518-1" "1683661383518-2"] nil]

(read-next 1 :from :my/queue :as :my/consumer1)

(read-next :all :from :my/queue :as :my/consumer1 :block 2000)
(read-next :all :from :my/queue :as :my/consumer1 :block [2 :seconds])
;=
</code></pre>
<p>See also:</p>
<ul>
<li><code>potamic.queue/read</code></li>
<li><code>potamic.queue/create-reader</code></li>
<li><code>potamic.queue/put</code></li>
</ul>
</div></div></div><div class="public anchor" id="var-Valid-Create-Queue-Opts"><h3>Valid-Create-Queue-Opts</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div></div></body></html>